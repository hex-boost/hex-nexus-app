name: Release e Deploy de Atualização

on:
  push:
    tags:
      - 'v*'  # Ativa quando uma tag com formato 'v*' é empurrada (ex: v1.0.1)

jobs:
  build-and-deploy:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # set-safe-directory: false # Usually not needed with actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.8.1 # Consider using a more recent version if compatible, e.g., 9.x

      - name: Set up Node.js
        uses: actions/setup-node@v3 # Consider using v4
        with:
          node-version: '22' # Use LTS or your required version
          cache: 'pnpm' # Add caching for pnpm
          cache-dependency-path: 'frontend/pnpm-lock.yaml' # Adjust path if needed

      - name: Get Tag Version
        id: get_version
        shell: bash
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_ENV

      - name: Set up Go
        uses: actions/setup-go@v4 # Consider using v5
        with:
          go-version: '1.22.3' # Use your required Go version
          cache: true # Enable Go build/module caching

      # --- ADD THIS STEP ---
      - name: Install MinGW (GCC for CGO)
        run: choco install mingw --no-progress --params "/InstallDir:C:\mingw-w64"
      # ---------------------

      - name: Install Mockery
        run: go install github.com/vektra/mockery/v2@v2.53.3 # Ensure this version is correct

      - name: Install Wails
        run: go install -v github.com/wailsapp/wails/v3/cmd/wails3@latest

      # Optional: Verify GCC is in PATH (for debugging)
      # - name: Verify GCC Path
      #   run: |
      #     echo $env:PATH
      #     gcc --version
      #   shell: pwsh

      - name: Build with Wails task (includes go build)
        run: wails3 task package # This command runs the go build internally
        env:
          APP_NAME: Nexus
          VERSION: ${{ env.VERSION }}
          API_URL: ${{ secrets.API_URL }}
          API_KEY: ${{ secrets.API_KEY }}
          PRODUCTION: true
          BIN_DIR: "bin"
          DIST_DIR: "dist"
          REFRESH_API_KEY: ${{ secrets.REFRESH_API_KEY }}
          CGO_ENABLED: "1"


          # GOOS: windows # Usually not needed when runs-on is windows-latest
          # GOARCH: amd64 # Usually default

      # (Rest of your workflow: Check artifacts, Upload, etc.)
      # ...
      - name: Check build artifacts
        shell: bash
        run: |
          echo "Listing build directory contents:"
          ls -la build/
          echo "Listing bin directory contents:"
          ls -la build/bin/ || echo "bin directory not found"
          echo "Searching for executable:"
          find . -name "*.exe" -type f
      - name: Upload to Update Server
        shell: bash
        env:
          API_KEY: ${{ secrets.API_KEY }}
          API_URL: ${{ secrets.API_URL }}
        run: |
          # Find main executable
          # Corrected path assuming build output structure
          EXE_PATH=$(find ./build/bin -name "Nexus.exe" -type f | head -1)

          # Find installer executable (Adjust path if wails3 task package outputs elsewhere)
          # Common NSIS output location for Wails might be build/windows/nsis
          INSTALLER_PATH=$(find ./build -name "Nexus-Setup-*.exe" -type f | head -1) # More specific pattern

          if [ -z "$EXE_PATH" ]; then
            echo "❌ No main executable found in ./build/bin/"
            # Add more diagnostics if needed
            echo "Searching everywhere:"
            find . -name "Nexus.exe" -type f
            exit 1
          fi

          if [ -z "$INSTALLER_PATH" ]; then
            echo "❌ No installer executable found starting in ./build/"
            # Add more diagnostics if needed
            echo "Searching everywhere:"
            find . -name "Nexus-Setup-*.exe" -type f
            exit 1
          fi

          echo "Found main executable at: $EXE_PATH"
          echo "Found installer at: $INSTALLER_PATH"

          # Create version record with verbose output
          echo "Creating version record for ${{ env.VERSION }}..."
          VERSION_RESPONSE=$(curl -v -s -X POST "${{env.API_URL}}/api/versions" \
          -H "Authorization: Bearer ${{ env.API_KEY }}" \
          -H "Content-Type: application/json" \
          -d "{\"data\":{\"version\":\"${{ env.VERSION }}\"}}")

          echo "API Response for version creation:"
          echo "$VERSION_RESPONSE"

          # Extract version ID (Improved robustness)
          VERSION_ID=$(echo "$VERSION_RESPONSE" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
          echo "Extracted Version ID: $VERSION_ID"

          if [ -z "$VERSION_ID" ] || ! [[ "$VERSION_ID" =~ ^[0-9]+$ ]]; then
            echo "Failed to extract a valid numeric version ID"
            exit 1
          fi

          # Upload main executable
          echo "Uploading main application binary..."
          UPLOAD_RESULT=$(curl -v -X POST "${{env.API_URL}}/api/upload" \
          -H "Authorization: Bearer ${{ env.API_KEY }}" \
          -F "files=@$EXE_PATH" \
          -F "refId=$VERSION_ID" \
          -F "ref=api::version.version" \
          -F "field=file" \
          -w "\nStatus code: %{http_code}" \
          -L)

          echo "Main Upload Result:"
          echo "$UPLOAD_RESULT"

          # Check if main upload was successful
          if echo "$UPLOAD_RESULT" | grep -q "Status code: 2[0-9][0-9]"; then
            echo "✅ Main executable upload completed successfully"

            # Upload installer executable
            echo "Uploading installer binary..."
            INSTALLER_UPLOAD_RESULT=$(curl -v -X POST "${{env.API_URL}}/api/upload" \
            -H "Authorization: Bearer ${{ env.API_KEY }}" \
            -F "files=@$INSTALLER_PATH" \
            -F "refId=$VERSION_ID" \
            -F "ref=api::version.version" \
            -F "field=installer" \
            -w "\nStatus code: %{http_code}" \
            -L)

            echo "Installer Upload Result:"
            echo "$INSTALLER_UPLOAD_RESULT"

            # Check if installer upload was successful
            if echo "$INSTALLER_UPLOAD_RESULT" | grep -q "Status code: 2[0-9][0-9]"; then
              echo "✅ Installer upload completed successfully"
            else
              echo "❌ Installer upload failed"
              exit 1
            fi
          else
            echo "❌ Main executable upload failed"
            exit 1
          fi